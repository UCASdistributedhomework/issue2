/**
 * Autogenerated by Thrift Compiler (0.13.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef Locker_H
#define Locker_H

#include <thrift/TDispatchProcessor.h>
#include <thrift/async/TConcurrentClientSyncInfo.h>
#include <memory>
#include "lock_types.h"



#ifdef _MSC_VER
  #pragma warning( push )
  #pragma warning (disable : 4250 ) //inheriting methods via dominance 
#endif

class LockerIf {
 public:
  virtual ~LockerIf() {}
  virtual bool client_register(const int32_t client_id, const bool is_retry) = 0;
  virtual bool client_exit(const int32_t client_id, const bool is_retry) = 0;
  virtual bool lock_request_register(const int32_t client_id, const bool is_retry) = 0;
  virtual bool lock_request_check(const int32_t client_id, const bool is_retry) = 0;
  virtual bool lock_request_release(const int32_t client_id, const bool is_retry) = 0;
};

class LockerIfFactory {
 public:
  typedef LockerIf Handler;

  virtual ~LockerIfFactory() {}

  virtual LockerIf* getHandler(const ::apache::thrift::TConnectionInfo& connInfo) = 0;
  virtual void releaseHandler(LockerIf* /* handler */) = 0;
};

class LockerIfSingletonFactory : virtual public LockerIfFactory {
 public:
  LockerIfSingletonFactory(const ::std::shared_ptr<LockerIf>& iface) : iface_(iface) {}
  virtual ~LockerIfSingletonFactory() {}

  virtual LockerIf* getHandler(const ::apache::thrift::TConnectionInfo&) {
    return iface_.get();
  }
  virtual void releaseHandler(LockerIf* /* handler */) {}

 protected:
  ::std::shared_ptr<LockerIf> iface_;
};

class LockerNull : virtual public LockerIf {
 public:
  virtual ~LockerNull() {}
  bool client_register(const int32_t /* client_id */, const bool /* is_retry */) {
    bool _return = false;
    return _return;
  }
  bool client_exit(const int32_t /* client_id */, const bool /* is_retry */) {
    bool _return = false;
    return _return;
  }
  bool lock_request_register(const int32_t /* client_id */, const bool /* is_retry */) {
    bool _return = false;
    return _return;
  }
  bool lock_request_check(const int32_t /* client_id */, const bool /* is_retry */) {
    bool _return = false;
    return _return;
  }
  bool lock_request_release(const int32_t /* client_id */, const bool /* is_retry */) {
    bool _return = false;
    return _return;
  }
};

typedef struct _Locker_client_register_args__isset {
  _Locker_client_register_args__isset() : client_id(false), is_retry(false) {}
  bool client_id :1;
  bool is_retry :1;
} _Locker_client_register_args__isset;

class Locker_client_register_args {
 public:

  Locker_client_register_args(const Locker_client_register_args&);
  Locker_client_register_args& operator=(const Locker_client_register_args&);
  Locker_client_register_args() : client_id(0), is_retry(0) {
  }

  virtual ~Locker_client_register_args() noexcept;
  int32_t client_id;
  bool is_retry;

  _Locker_client_register_args__isset __isset;

  void __set_client_id(const int32_t val);

  void __set_is_retry(const bool val);

  bool operator == (const Locker_client_register_args & rhs) const
  {
    if (!(client_id == rhs.client_id))
      return false;
    if (!(is_retry == rhs.is_retry))
      return false;
    return true;
  }
  bool operator != (const Locker_client_register_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Locker_client_register_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Locker_client_register_pargs {
 public:


  virtual ~Locker_client_register_pargs() noexcept;
  const int32_t* client_id;
  const bool* is_retry;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Locker_client_register_result__isset {
  _Locker_client_register_result__isset() : success(false) {}
  bool success :1;
} _Locker_client_register_result__isset;

class Locker_client_register_result {
 public:

  Locker_client_register_result(const Locker_client_register_result&);
  Locker_client_register_result& operator=(const Locker_client_register_result&);
  Locker_client_register_result() : success(0) {
  }

  virtual ~Locker_client_register_result() noexcept;
  bool success;

  _Locker_client_register_result__isset __isset;

  void __set_success(const bool val);

  bool operator == (const Locker_client_register_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Locker_client_register_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Locker_client_register_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Locker_client_register_presult__isset {
  _Locker_client_register_presult__isset() : success(false) {}
  bool success :1;
} _Locker_client_register_presult__isset;

class Locker_client_register_presult {
 public:


  virtual ~Locker_client_register_presult() noexcept;
  bool* success;

  _Locker_client_register_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Locker_client_exit_args__isset {
  _Locker_client_exit_args__isset() : client_id(false), is_retry(false) {}
  bool client_id :1;
  bool is_retry :1;
} _Locker_client_exit_args__isset;

class Locker_client_exit_args {
 public:

  Locker_client_exit_args(const Locker_client_exit_args&);
  Locker_client_exit_args& operator=(const Locker_client_exit_args&);
  Locker_client_exit_args() : client_id(0), is_retry(0) {
  }

  virtual ~Locker_client_exit_args() noexcept;
  int32_t client_id;
  bool is_retry;

  _Locker_client_exit_args__isset __isset;

  void __set_client_id(const int32_t val);

  void __set_is_retry(const bool val);

  bool operator == (const Locker_client_exit_args & rhs) const
  {
    if (!(client_id == rhs.client_id))
      return false;
    if (!(is_retry == rhs.is_retry))
      return false;
    return true;
  }
  bool operator != (const Locker_client_exit_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Locker_client_exit_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Locker_client_exit_pargs {
 public:


  virtual ~Locker_client_exit_pargs() noexcept;
  const int32_t* client_id;
  const bool* is_retry;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Locker_client_exit_result__isset {
  _Locker_client_exit_result__isset() : success(false) {}
  bool success :1;
} _Locker_client_exit_result__isset;

class Locker_client_exit_result {
 public:

  Locker_client_exit_result(const Locker_client_exit_result&);
  Locker_client_exit_result& operator=(const Locker_client_exit_result&);
  Locker_client_exit_result() : success(0) {
  }

  virtual ~Locker_client_exit_result() noexcept;
  bool success;

  _Locker_client_exit_result__isset __isset;

  void __set_success(const bool val);

  bool operator == (const Locker_client_exit_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Locker_client_exit_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Locker_client_exit_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Locker_client_exit_presult__isset {
  _Locker_client_exit_presult__isset() : success(false) {}
  bool success :1;
} _Locker_client_exit_presult__isset;

class Locker_client_exit_presult {
 public:


  virtual ~Locker_client_exit_presult() noexcept;
  bool* success;

  _Locker_client_exit_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Locker_lock_request_register_args__isset {
  _Locker_lock_request_register_args__isset() : client_id(false), is_retry(false) {}
  bool client_id :1;
  bool is_retry :1;
} _Locker_lock_request_register_args__isset;

class Locker_lock_request_register_args {
 public:

  Locker_lock_request_register_args(const Locker_lock_request_register_args&);
  Locker_lock_request_register_args& operator=(const Locker_lock_request_register_args&);
  Locker_lock_request_register_args() : client_id(0), is_retry(0) {
  }

  virtual ~Locker_lock_request_register_args() noexcept;
  int32_t client_id;
  bool is_retry;

  _Locker_lock_request_register_args__isset __isset;

  void __set_client_id(const int32_t val);

  void __set_is_retry(const bool val);

  bool operator == (const Locker_lock_request_register_args & rhs) const
  {
    if (!(client_id == rhs.client_id))
      return false;
    if (!(is_retry == rhs.is_retry))
      return false;
    return true;
  }
  bool operator != (const Locker_lock_request_register_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Locker_lock_request_register_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Locker_lock_request_register_pargs {
 public:


  virtual ~Locker_lock_request_register_pargs() noexcept;
  const int32_t* client_id;
  const bool* is_retry;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Locker_lock_request_register_result__isset {
  _Locker_lock_request_register_result__isset() : success(false) {}
  bool success :1;
} _Locker_lock_request_register_result__isset;

class Locker_lock_request_register_result {
 public:

  Locker_lock_request_register_result(const Locker_lock_request_register_result&);
  Locker_lock_request_register_result& operator=(const Locker_lock_request_register_result&);
  Locker_lock_request_register_result() : success(0) {
  }

  virtual ~Locker_lock_request_register_result() noexcept;
  bool success;

  _Locker_lock_request_register_result__isset __isset;

  void __set_success(const bool val);

  bool operator == (const Locker_lock_request_register_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Locker_lock_request_register_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Locker_lock_request_register_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Locker_lock_request_register_presult__isset {
  _Locker_lock_request_register_presult__isset() : success(false) {}
  bool success :1;
} _Locker_lock_request_register_presult__isset;

class Locker_lock_request_register_presult {
 public:


  virtual ~Locker_lock_request_register_presult() noexcept;
  bool* success;

  _Locker_lock_request_register_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Locker_lock_request_check_args__isset {
  _Locker_lock_request_check_args__isset() : client_id(false), is_retry(false) {}
  bool client_id :1;
  bool is_retry :1;
} _Locker_lock_request_check_args__isset;

class Locker_lock_request_check_args {
 public:

  Locker_lock_request_check_args(const Locker_lock_request_check_args&);
  Locker_lock_request_check_args& operator=(const Locker_lock_request_check_args&);
  Locker_lock_request_check_args() : client_id(0), is_retry(0) {
  }

  virtual ~Locker_lock_request_check_args() noexcept;
  int32_t client_id;
  bool is_retry;

  _Locker_lock_request_check_args__isset __isset;

  void __set_client_id(const int32_t val);

  void __set_is_retry(const bool val);

  bool operator == (const Locker_lock_request_check_args & rhs) const
  {
    if (!(client_id == rhs.client_id))
      return false;
    if (!(is_retry == rhs.is_retry))
      return false;
    return true;
  }
  bool operator != (const Locker_lock_request_check_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Locker_lock_request_check_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Locker_lock_request_check_pargs {
 public:


  virtual ~Locker_lock_request_check_pargs() noexcept;
  const int32_t* client_id;
  const bool* is_retry;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Locker_lock_request_check_result__isset {
  _Locker_lock_request_check_result__isset() : success(false) {}
  bool success :1;
} _Locker_lock_request_check_result__isset;

class Locker_lock_request_check_result {
 public:

  Locker_lock_request_check_result(const Locker_lock_request_check_result&);
  Locker_lock_request_check_result& operator=(const Locker_lock_request_check_result&);
  Locker_lock_request_check_result() : success(0) {
  }

  virtual ~Locker_lock_request_check_result() noexcept;
  bool success;

  _Locker_lock_request_check_result__isset __isset;

  void __set_success(const bool val);

  bool operator == (const Locker_lock_request_check_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Locker_lock_request_check_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Locker_lock_request_check_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Locker_lock_request_check_presult__isset {
  _Locker_lock_request_check_presult__isset() : success(false) {}
  bool success :1;
} _Locker_lock_request_check_presult__isset;

class Locker_lock_request_check_presult {
 public:


  virtual ~Locker_lock_request_check_presult() noexcept;
  bool* success;

  _Locker_lock_request_check_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Locker_lock_request_release_args__isset {
  _Locker_lock_request_release_args__isset() : client_id(false), is_retry(false) {}
  bool client_id :1;
  bool is_retry :1;
} _Locker_lock_request_release_args__isset;

class Locker_lock_request_release_args {
 public:

  Locker_lock_request_release_args(const Locker_lock_request_release_args&);
  Locker_lock_request_release_args& operator=(const Locker_lock_request_release_args&);
  Locker_lock_request_release_args() : client_id(0), is_retry(0) {
  }

  virtual ~Locker_lock_request_release_args() noexcept;
  int32_t client_id;
  bool is_retry;

  _Locker_lock_request_release_args__isset __isset;

  void __set_client_id(const int32_t val);

  void __set_is_retry(const bool val);

  bool operator == (const Locker_lock_request_release_args & rhs) const
  {
    if (!(client_id == rhs.client_id))
      return false;
    if (!(is_retry == rhs.is_retry))
      return false;
    return true;
  }
  bool operator != (const Locker_lock_request_release_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Locker_lock_request_release_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Locker_lock_request_release_pargs {
 public:


  virtual ~Locker_lock_request_release_pargs() noexcept;
  const int32_t* client_id;
  const bool* is_retry;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Locker_lock_request_release_result__isset {
  _Locker_lock_request_release_result__isset() : success(false) {}
  bool success :1;
} _Locker_lock_request_release_result__isset;

class Locker_lock_request_release_result {
 public:

  Locker_lock_request_release_result(const Locker_lock_request_release_result&);
  Locker_lock_request_release_result& operator=(const Locker_lock_request_release_result&);
  Locker_lock_request_release_result() : success(0) {
  }

  virtual ~Locker_lock_request_release_result() noexcept;
  bool success;

  _Locker_lock_request_release_result__isset __isset;

  void __set_success(const bool val);

  bool operator == (const Locker_lock_request_release_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Locker_lock_request_release_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Locker_lock_request_release_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Locker_lock_request_release_presult__isset {
  _Locker_lock_request_release_presult__isset() : success(false) {}
  bool success :1;
} _Locker_lock_request_release_presult__isset;

class Locker_lock_request_release_presult {
 public:


  virtual ~Locker_lock_request_release_presult() noexcept;
  bool* success;

  _Locker_lock_request_release_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class LockerClient : virtual public LockerIf {
 public:
  LockerClient(std::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
    setProtocol(prot);
  }
  LockerClient(std::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, std::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    setProtocol(iprot,oprot);
  }
 private:
  void setProtocol(std::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
  setProtocol(prot,prot);
  }
  void setProtocol(std::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, std::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    piprot_=iprot;
    poprot_=oprot;
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
 public:
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  bool client_register(const int32_t client_id, const bool is_retry);
  void send_client_register(const int32_t client_id, const bool is_retry);
  bool recv_client_register();
  bool client_exit(const int32_t client_id, const bool is_retry);
  void send_client_exit(const int32_t client_id, const bool is_retry);
  bool recv_client_exit();
  bool lock_request_register(const int32_t client_id, const bool is_retry);
  void send_lock_request_register(const int32_t client_id, const bool is_retry);
  bool recv_lock_request_register();
  bool lock_request_check(const int32_t client_id, const bool is_retry);
  void send_lock_request_check(const int32_t client_id, const bool is_retry);
  bool recv_lock_request_check();
  bool lock_request_release(const int32_t client_id, const bool is_retry);
  void send_lock_request_release(const int32_t client_id, const bool is_retry);
  bool recv_lock_request_release();
 protected:
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
};

class LockerProcessor : public ::apache::thrift::TDispatchProcessor {
 protected:
  ::std::shared_ptr<LockerIf> iface_;
  virtual bool dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext);
 private:
  typedef  void (LockerProcessor::*ProcessFunction)(int32_t, ::apache::thrift::protocol::TProtocol*, ::apache::thrift::protocol::TProtocol*, void*);
  typedef std::map<std::string, ProcessFunction> ProcessMap;
  ProcessMap processMap_;
  void process_client_register(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_client_exit(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_lock_request_register(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_lock_request_check(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_lock_request_release(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
 public:
  LockerProcessor(::std::shared_ptr<LockerIf> iface) :
    iface_(iface) {
    processMap_["client_register"] = &LockerProcessor::process_client_register;
    processMap_["client_exit"] = &LockerProcessor::process_client_exit;
    processMap_["lock_request_register"] = &LockerProcessor::process_lock_request_register;
    processMap_["lock_request_check"] = &LockerProcessor::process_lock_request_check;
    processMap_["lock_request_release"] = &LockerProcessor::process_lock_request_release;
  }

  virtual ~LockerProcessor() {}
};

class LockerProcessorFactory : public ::apache::thrift::TProcessorFactory {
 public:
  LockerProcessorFactory(const ::std::shared_ptr< LockerIfFactory >& handlerFactory) :
      handlerFactory_(handlerFactory) {}

  ::std::shared_ptr< ::apache::thrift::TProcessor > getProcessor(const ::apache::thrift::TConnectionInfo& connInfo);

 protected:
  ::std::shared_ptr< LockerIfFactory > handlerFactory_;
};

class LockerMultiface : virtual public LockerIf {
 public:
  LockerMultiface(std::vector<std::shared_ptr<LockerIf> >& ifaces) : ifaces_(ifaces) {
  }
  virtual ~LockerMultiface() {}
 protected:
  std::vector<std::shared_ptr<LockerIf> > ifaces_;
  LockerMultiface() {}
  void add(::std::shared_ptr<LockerIf> iface) {
    ifaces_.push_back(iface);
  }
 public:
  bool client_register(const int32_t client_id, const bool is_retry) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->client_register(client_id, is_retry);
    }
    return ifaces_[i]->client_register(client_id, is_retry);
  }

  bool client_exit(const int32_t client_id, const bool is_retry) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->client_exit(client_id, is_retry);
    }
    return ifaces_[i]->client_exit(client_id, is_retry);
  }

  bool lock_request_register(const int32_t client_id, const bool is_retry) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->lock_request_register(client_id, is_retry);
    }
    return ifaces_[i]->lock_request_register(client_id, is_retry);
  }

  bool lock_request_check(const int32_t client_id, const bool is_retry) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->lock_request_check(client_id, is_retry);
    }
    return ifaces_[i]->lock_request_check(client_id, is_retry);
  }

  bool lock_request_release(const int32_t client_id, const bool is_retry) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->lock_request_release(client_id, is_retry);
    }
    return ifaces_[i]->lock_request_release(client_id, is_retry);
  }

};

// The 'concurrent' client is a thread safe client that correctly handles
// out of order responses.  It is slower than the regular client, so should
// only be used when you need to share a connection among multiple threads
class LockerConcurrentClient : virtual public LockerIf {
 public:
  LockerConcurrentClient(std::shared_ptr< ::apache::thrift::protocol::TProtocol> prot, std::shared_ptr<::apache::thrift::async::TConcurrentClientSyncInfo> sync) : sync_(sync)
{
    setProtocol(prot);
  }
  LockerConcurrentClient(std::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, std::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot, std::shared_ptr<::apache::thrift::async::TConcurrentClientSyncInfo> sync) : sync_(sync)
{
    setProtocol(iprot,oprot);
  }
 private:
  void setProtocol(std::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
  setProtocol(prot,prot);
  }
  void setProtocol(std::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, std::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    piprot_=iprot;
    poprot_=oprot;
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
 public:
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  bool client_register(const int32_t client_id, const bool is_retry);
  int32_t send_client_register(const int32_t client_id, const bool is_retry);
  bool recv_client_register(const int32_t seqid);
  bool client_exit(const int32_t client_id, const bool is_retry);
  int32_t send_client_exit(const int32_t client_id, const bool is_retry);
  bool recv_client_exit(const int32_t seqid);
  bool lock_request_register(const int32_t client_id, const bool is_retry);
  int32_t send_lock_request_register(const int32_t client_id, const bool is_retry);
  bool recv_lock_request_register(const int32_t seqid);
  bool lock_request_check(const int32_t client_id, const bool is_retry);
  int32_t send_lock_request_check(const int32_t client_id, const bool is_retry);
  bool recv_lock_request_check(const int32_t seqid);
  bool lock_request_release(const int32_t client_id, const bool is_retry);
  int32_t send_lock_request_release(const int32_t client_id, const bool is_retry);
  bool recv_lock_request_release(const int32_t seqid);
 protected:
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
  std::shared_ptr<::apache::thrift::async::TConcurrentClientSyncInfo> sync_;
};

#ifdef _MSC_VER
  #pragma warning( pop )
#endif



#endif
